# Srpc

手写rpc项目

## 学习笔记

rpc远程过程调用是一种通信协议，允许调用不同进程空间的程序。

1. restful接口需要额外的定义，而rpc调用更接近于直接调用
2. 基于http协议的restful报文冗余，承载了过多无效信息，rpc使用自定义的协议格式，减少冗余报文
3. rpc采用更高效的序列化协议，将文本转为二进制传输
4. rpc灵活，更容易扩展和集成诸如注册中心、负载均衡等功能

rpc框架解决的问题：确定传输协议、报文编码格式、可用性问题（连接超时、异步请求和并发）、当服务端实例很多时，客户端只关心能否获取到期待的结果，因此需要注册中心和负载均衡，注册中心还需要实现服务动态添加、删除，使用心跳确保服务处于可用状态等功能；而当服务端没有统一的rpc框架时，就需要实现消息编解码、连接池、收发线程、超时处理等业务之外的重复技术劳动，即是rpc框架所需要具备的能力

grpc、rpcx、go-micro都是成熟的rpc框架

Srpc只实现rpc框架中最为重要的部分，从零实现go语言官方的标准库net/rpc，并新增了协议交换、注册中心、服务发现、负载均衡、超时处理等特性

使用encoding/gob实现消息的编解码，即序列化与反序列化，是go语言自带的二进制序列化协议实现，并实现一个简易的服务端，仅接受消息，不处理

对于rpc协议来说，客户端与服务端的通信需要协商一些内容，需要自主设计，首先为了提升性能，一般在报文的最开始会规划固定的字节用于协商相关信息，首先实现协商消息的编解码方式，将这部分信息放到结构体Option中承载

二、实现一个支持异步和并发的高性能客户端：

同步调用：调用方发起请求后，必须阻塞等待结果返回才能继续后续操作，整个过程是线性串行的
异步调用：调用方发起请求后立即返回，无需等待结果，通过回调、轮询或通道机制异步结构结果，允许并行处理其他任务


还有一个问题，就是响应接收是一直在接收的，那么如何区分不同请求的响应，在请求写入pending时又是如何处理的，在代码层面是如何实现的？
seq是客户端连接实例的一个字段，客户端初始化seq都是1，对于该连接后续的其他请求，在写入pending映射时，会seq++，从而区分不同的请求进行存储；在接受响应时，首先会接受响应头，从中得到请求seq，然后从pending映射中移除对应的请求记录，返回该请求的Call对象，针对该Call对象进行请求的处理（Done通道是Call对象的一个属性，因此可以控制每一个请求的完整生命周期）



三、通过反射实现服务注册功能，在服务端实现服务调用：

在go语言的net/rpc包中，为了使一个结构体的方法能够被远程调用，需要满足五个条件：
1、方法所属的结构体类型名以大写字母开头：即结构体类型必须是公开的，因为rpc框架需要通过反射动态注册和识别服务类型，若类型未导出，则无法通过反射获取方法信息
2、方法本身是导出的：go的反射机制只能访问导出的方法，私有方法对其他包不可见，rpc框架无法发现并注册他们
3、方法必须有两个参数，且均为导出类型或内置类型：参数1表示客户端传递的请求参数，需支持序列化，参数2表示服务端返回的响应内容，需支持反序列化
4、方法的第二个参数必须是指针：rpc框架需要将服务端处理的结果写回客户端的变量中，若为值类型则服务端修改的只是参数的副本
5、方法的返回值必须是error类型：通过返回error客户端可以明确知道调用是否成功，并处理可能的错误
总的来说，是因为反射机制的限制，因为要使用反射动态注册和调用方法，还有序列化和反序列化的要求，还需要保持语义一致性，即通过指针修改返回值，通过error传递错误信息，从而可以确保rpc调用的行为与本地方法调用一致
若通过硬编码来实现结构体与服务的映射，那么每暴露一个方法，就需要编写等量的代码，可以通过反射获取某个结构体的所有方法，并通过方法获取到其对应的所有参数类型和返回值

go的反射机制：
通过标准库reflect实现，允许程序在运行时动态检查变量类型、操作对象属性和方法，核心围绕两个类型：
1、reflect.Type：类型信息；表示go类型的元信息接口，可通过reflect.TypeOf(x)获取，包含方法如Kind()用于返回基础类型，Name()返回类型名，NumField()返回结构体字段数量等
2、reflect.Value：值信息；封装了任意类型值的反射对象，可通过reflect.ValueOf(x)获取，包含方法如Type()表示关联的Type，Kind()表示值的基础类型，Elem()解引用指针等
反射三定律：
1、接口-->反射对象：通过TypeOf/ValueOf将接口转换为反射对象
2、反射对象-->接口：通过Interface()将反射对象转换为接口
3、要修改反射对象，其值必须可设置：通过ValueOf获取反射对象后，若要修改其值，必须是可设置的，即通过Elem()获取指针指向的元素，然后再修改
反射典型的应用场景：动态类型检查与转换、动态实例化对象、动态调用方法与函数、结构体字段与标签处理、序列化与反序列化
关于反射的操作实际上还不太懂？？

关于rpc服务的入参和出参的类型，内部统一指针处理？？？

对于超时处理，总超时时间和分超时时间如何区分？？？


四、增加连接超时的处理机制，增加服务端处理超时的处理机制：
需要客户端处理超时的地方有：
1. 与服务端建立连接导致的超时
2. 发送请求到服务端，写报文导致的超时
3. 等待服务端处理时，等待处理导致的超时
4. 从服务端接收响应时，读报文导致的超时
需要服务端处理超时的地方有：
1. 读取客户端请求报文时，读报文导致的超时
2. 发送响应报文时，写报文导致的超时
3. 调用映射服务的方法时，处理报文导致的超时
sprc在3个地方添加了超时处理机制：
1. 客户端创建连接时
2. 客户端Client.Call()调用rpc方法整个过程导致的超时
3. 服务端处理报文，即Server.handleRequest超时

go的context库：
是用于管理跨api边界的请求生命周期和工具，主要解决这些问题
1. 取消信号传递：允许在多个goroutine或函数间传递取消信号，实现级联取消
2. 超时控制：为操作设置截至时间或超时时间，自动触发取消逻辑
3. 数据传递：安全的在请求链中传递与请求相关的元数据，避免全局变量污染
4. 资源管理：确保在请求取消或超时后，及时释放资源

五：支持http协议，基于http实现一个简单的debug页面
rpc的消息格式与标准的http协议并不兼容，需要一个协议转换过程，http协议的connect方法提供了一种在不同协议之间建立连接的机制
在https通信中，浏览器通过http connect来告诉代理服务器请求的目标地址和端口，代理服务器与目标服务器建立连接后只需要转发数据包即可
rpc服务端转换：需要解析http请求并将其转换为rpc调用的格式
客户端转换：新增通过http connect请求创建连接的逻辑，
这里面涉及添加一个代理服务器吗？
支持http协议的好处在于，rpc服务仅仅使用了监听端口的/_srpc_路径，其他路径可以提供诸如日志、统计等功能
http.Handle用于将url路径与实现了http.Handler接口的对象绑定的函数，即将HTTP路由到第二个参数的ServeHTTP处理方法



问题整理：

2. 支持异步和并发的高性能客户端：

3. 通过反射实现服务注册功能，在服务端实现服务调用

4. 增加连接超时的处理机制，增加服务端处理超时的处理机制

5. 支持http协议，基于http实现一个简单的debug页面：服务端起两个http服务，一个暴露rpc服务，一个暴露debug页面，客户端需要通过发起http connect请求，让rpc服务端劫持到底层的tcp连接，进行后续基于tcp连接进行rpc协议的通信



对于调用方注册rpc服务和服务端启动服务等待连接来说，都是调用方直接调用包级的Accept函数和Register函数，这样做的好处是：
1. 零配置启动，用户无需手动创建和管理server实例，用户无需关心服务器与服务注册表的具体实现
2. 单例模式：全局唯一的DefaultServer实例共享同一组服务注册表和连接池，避免多实例场景下重复分配内存
代码中的连接复用设计，体现在serveCodec函数中，通过单个tcp连接的for循环处理多个请求/响应，直到连接关闭或失败，从而减少tcp三次握手和tls协商的开销，长连接的形式适合长连接高并发场景，而显式使用连接池，适合短链接高频次请求，如rest api网关，需要通过池化避免连接建立开销

学习到一个写代码的思路：将原生支持的包中的某些功能，封装成新的函数，在函数中进行处理，对外暴露屏蔽了底层实现，比如接受连接，net包中有net.Listener接口，有Accept方法，将其封装成Accept方法，对外暴露，屏蔽底层实现，在Accept方法中进行处理