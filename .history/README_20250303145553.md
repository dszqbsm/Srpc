# Srpc

手写rpc项目

## 学习笔记

rpc远程过程调用是一种通信协议，允许调用不同进程空间的程序。

1. restful接口需要额外的定义，而rpc调用更接近于直接调用
2. 基于http协议的restful报文冗余，承载了过多无效信息，rpc使用自定义的协议格式，减少冗余报文
3. rpc采用更高效的序列化协议，将文本转为二进制传输
4. rpc灵活，更容易扩展和集成诸如注册中心、负载均衡等功能

rpc框架解决的问题：确定传输协议、报文编码格式、可用性问题（连接超时、异步请求和并发）、当服务端实例很多时，客户端只关心能否获取到期待的结果，因此需要注册中心和负载均衡，注册中心还需要实现服务动态添加、删除，使用心跳确保服务处于可用状态等功能；而当服务端没有统一的rpc框架时，就需要实现消息编解码、连接池、收发线程、超时处理等业务之外的重复技术劳动，即是rpc框架所需要具备的能力

grpc、rpcx、go-micro都是成熟的rpc框架

Srpc只实现rpc框架中最为重要的部分，从零实现go语言官方的标准库net/rpc，并新增了协议交换、注册中心、服务发现、负载均衡、超时处理等特性

使用encoding/gob实现消息的编解码，即序列化与反序列化，是go语言自带的二进制序列化协议实现，并实现一个简易的服务端，仅接受消息，不处理

对于rpc协议来说，客户端与服务端的通信需要协商一些内容，需要自主设计，首先为了提升性能，一般在报文的最开始会规划固定的字节用于协商相关信息，首先实现协商消息的编解码方式，将这部分信息放到结构体Option中承载

实现一个支持异步和并发的高性能客户端

同步调用：调用方发起请求后，必须阻塞等待结果返回才能继续后续操作，整个过程是线性串行的
异步调用：调用方发起请求后立即返回，无需等待结果，通过回调、轮询或通道机制异步结构结果，允许并行处理其他任务


还有一个问题，就是响应接收是一直在接收的，那么如何区分不同请求的响应，在请求写入pending时又是如何处理的，在代码层面是如何实现的？








问题整理：

1. 支持异步和并发的高性能客户端：


学习到一个写代码的思路：将原生支持的包中的某些功能，封装成新的函数，在函数中进行处理，对外暴露屏蔽了底层实现，比如接受连接，net包中有net.Listener接口，有Accept方法，将其封装成Accept方法，对外暴露，屏蔽底层实现，在Accept方法中进行处理